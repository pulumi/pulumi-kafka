// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kafka

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-kafka/sdk/v3/go/kafka/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The `Quota` resource manages Kafka quotas, which are used to limit resource usage and prevent any single client from monopolizing broker resources. Quotas can be applied to clients, users, or IP addresses to control bandwidth and request rates.
//
// ## Example Usage
//
// ### Client ID Quota
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kafka/sdk/v3/go/kafka"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Limit a specific client's bandwidth
//			_, err := kafka.NewQuota(ctx, "mobile_app", &kafka.QuotaArgs{
//				EntityName: pulumi.String("mobile-app-v1"),
//				EntityType: pulumi.String("client-id"),
//				Config: pulumi.StringMap{
//					"consumer_byte_rate": pulumi.String("5000000"),
//					"producer_byte_rate": pulumi.String("2500000"),
//					"request_percentage": pulumi.String("200"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### User Quota
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kafka/sdk/v3/go/kafka"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Set quotas for a specific user
//			_, err := kafka.NewQuota(ctx, "service_account", &kafka.QuotaArgs{
//				EntityName: pulumi.String("payment-service"),
//				EntityType: pulumi.String("user"),
//				Config: pulumi.StringMap{
//					"consumer_byte_rate": pulumi.String("10000000"),
//					"producer_byte_rate": pulumi.String("10000000"),
//					"request_percentage": pulumi.String("400"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Default User Quota
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kafka/sdk/v3/go/kafka"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Set default quotas for all users (when entity_name is omitted)
//			_, err := kafka.NewQuota(ctx, "default_user", &kafka.QuotaArgs{
//				EntityType: pulumi.String("user"),
//				Config: pulumi.StringMap{
//					"consumer_byte_rate": pulumi.String("2000000"),
//					"producer_byte_rate": pulumi.String("1000000"),
//					"request_percentage": pulumi.String("100"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### IP Address Quota
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kafka/sdk/v3/go/kafka"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Rate limit connections from a specific IP
//			_, err := kafka.NewQuota(ctx, "external_ip", &kafka.QuotaArgs{
//				EntityName: pulumi.String("203.0.113.0"),
//				EntityType: pulumi.String("ip"),
//				Config: pulumi.StringMap{
//					"connection_creation_rate": pulumi.String("10"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Quota Configuration Options
//
// ### Bandwidth Quotas
// - `producerByteRate` - The maximum bytes per second that can be produced by the entity
// - `consumerByteRate` - The maximum bytes per second that can be consumed by the entity
//
// ### Request Rate Quotas
// - `requestPercentage` - The percentage of CPU time on each broker that the entity can use for requests. Values > 100% indicate multiple CPUs (e.g., 200% = 2 CPUs)
//
// ### Connection Quotas (IP-based only)
// - `connectionCreationRate` - The maximum rate of new connections per second from the IP address
//
// ## Quota Precedence
//
// When multiple quotas apply to a request, Kafka uses the most specific quota:
//
// 1. `/config/users/<user>/clients/<client-id>` (most specific)
// 2. `/config/users/<user>/clients/<default>`
// 3. `/config/users/<user>`
// 4. `/config/users/<default>/clients/<client-id>`
// 5. `/config/users/<default>/clients/<default>`
// 6. `/config/users/<default>` (least specific)
//
// ## Best Practices
//
// 1. **Start with Conservative Defaults**: Set reasonable default quotas for all users/clients and then create specific quotas for services that need higher limits.
//
// 2. **Monitor Quota Usage**: Use Kafka metrics to monitor quota utilization and adjust as needed. Look for throttling metrics to identify when quotas are being hit.
//
// 3. **Use Request Percentage Carefully**: The `requestPercentage` quota affects CPU usage. Values over 100% mean the client can use more than one CPU core.
//
// 4. **Plan for Growth**: Set quotas with some headroom to accommodate traffic growth, but not so high that a misbehaving client can impact the cluster.
//
// 5. **Different Quotas for Different Environments**: Use stricter quotas in development/staging environments compared to production.
//
// > **Note:** Quotas are applied immediately but may take a few seconds to propagate across all brokers.
//
// ## Import
//
// Kafka quotas can be imported using the entity type and name:
//
// # For named entities
//
// ```sh
// $ pulumi import kafka:index/quota:Quota example client-id:my-client
// ```
//
// For default quotas (no entity name)
//
// ```sh
// $ pulumi import kafka:index/quota:Quota default_user user:
// ```
type Quota struct {
	pulumi.CustomResourceState

	// A map of string k/v properties.
	Config pulumi.StringMapOutput `pulumi:"config"`
	// The name of the entity (if entityName is not provided, it will create entity-default Kafka quota)
	EntityName pulumi.StringPtrOutput `pulumi:"entityName"`
	// The type of the entity (client-id, user, ip)
	EntityType pulumi.StringOutput `pulumi:"entityType"`
}

// NewQuota registers a new resource with the given unique name, arguments, and options.
func NewQuota(ctx *pulumi.Context,
	name string, args *QuotaArgs, opts ...pulumi.ResourceOption) (*Quota, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.EntityType == nil {
		return nil, errors.New("invalid value for required argument 'EntityType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Quota
	err := ctx.RegisterResource("kafka:index/quota:Quota", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetQuota gets an existing Quota resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetQuota(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *QuotaState, opts ...pulumi.ResourceOption) (*Quota, error) {
	var resource Quota
	err := ctx.ReadResource("kafka:index/quota:Quota", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Quota resources.
type quotaState struct {
	// A map of string k/v properties.
	Config map[string]string `pulumi:"config"`
	// The name of the entity (if entityName is not provided, it will create entity-default Kafka quota)
	EntityName *string `pulumi:"entityName"`
	// The type of the entity (client-id, user, ip)
	EntityType *string `pulumi:"entityType"`
}

type QuotaState struct {
	// A map of string k/v properties.
	Config pulumi.StringMapInput
	// The name of the entity (if entityName is not provided, it will create entity-default Kafka quota)
	EntityName pulumi.StringPtrInput
	// The type of the entity (client-id, user, ip)
	EntityType pulumi.StringPtrInput
}

func (QuotaState) ElementType() reflect.Type {
	return reflect.TypeOf((*quotaState)(nil)).Elem()
}

type quotaArgs struct {
	// A map of string k/v properties.
	Config map[string]string `pulumi:"config"`
	// The name of the entity (if entityName is not provided, it will create entity-default Kafka quota)
	EntityName *string `pulumi:"entityName"`
	// The type of the entity (client-id, user, ip)
	EntityType string `pulumi:"entityType"`
}

// The set of arguments for constructing a Quota resource.
type QuotaArgs struct {
	// A map of string k/v properties.
	Config pulumi.StringMapInput
	// The name of the entity (if entityName is not provided, it will create entity-default Kafka quota)
	EntityName pulumi.StringPtrInput
	// The type of the entity (client-id, user, ip)
	EntityType pulumi.StringInput
}

func (QuotaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*quotaArgs)(nil)).Elem()
}

type QuotaInput interface {
	pulumi.Input

	ToQuotaOutput() QuotaOutput
	ToQuotaOutputWithContext(ctx context.Context) QuotaOutput
}

func (*Quota) ElementType() reflect.Type {
	return reflect.TypeOf((**Quota)(nil)).Elem()
}

func (i *Quota) ToQuotaOutput() QuotaOutput {
	return i.ToQuotaOutputWithContext(context.Background())
}

func (i *Quota) ToQuotaOutputWithContext(ctx context.Context) QuotaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QuotaOutput)
}

// QuotaArrayInput is an input type that accepts QuotaArray and QuotaArrayOutput values.
// You can construct a concrete instance of `QuotaArrayInput` via:
//
//	QuotaArray{ QuotaArgs{...} }
type QuotaArrayInput interface {
	pulumi.Input

	ToQuotaArrayOutput() QuotaArrayOutput
	ToQuotaArrayOutputWithContext(context.Context) QuotaArrayOutput
}

type QuotaArray []QuotaInput

func (QuotaArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Quota)(nil)).Elem()
}

func (i QuotaArray) ToQuotaArrayOutput() QuotaArrayOutput {
	return i.ToQuotaArrayOutputWithContext(context.Background())
}

func (i QuotaArray) ToQuotaArrayOutputWithContext(ctx context.Context) QuotaArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QuotaArrayOutput)
}

// QuotaMapInput is an input type that accepts QuotaMap and QuotaMapOutput values.
// You can construct a concrete instance of `QuotaMapInput` via:
//
//	QuotaMap{ "key": QuotaArgs{...} }
type QuotaMapInput interface {
	pulumi.Input

	ToQuotaMapOutput() QuotaMapOutput
	ToQuotaMapOutputWithContext(context.Context) QuotaMapOutput
}

type QuotaMap map[string]QuotaInput

func (QuotaMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Quota)(nil)).Elem()
}

func (i QuotaMap) ToQuotaMapOutput() QuotaMapOutput {
	return i.ToQuotaMapOutputWithContext(context.Background())
}

func (i QuotaMap) ToQuotaMapOutputWithContext(ctx context.Context) QuotaMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QuotaMapOutput)
}

type QuotaOutput struct{ *pulumi.OutputState }

func (QuotaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Quota)(nil)).Elem()
}

func (o QuotaOutput) ToQuotaOutput() QuotaOutput {
	return o
}

func (o QuotaOutput) ToQuotaOutputWithContext(ctx context.Context) QuotaOutput {
	return o
}

// A map of string k/v properties.
func (o QuotaOutput) Config() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Quota) pulumi.StringMapOutput { return v.Config }).(pulumi.StringMapOutput)
}

// The name of the entity (if entityName is not provided, it will create entity-default Kafka quota)
func (o QuotaOutput) EntityName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Quota) pulumi.StringPtrOutput { return v.EntityName }).(pulumi.StringPtrOutput)
}

// The type of the entity (client-id, user, ip)
func (o QuotaOutput) EntityType() pulumi.StringOutput {
	return o.ApplyT(func(v *Quota) pulumi.StringOutput { return v.EntityType }).(pulumi.StringOutput)
}

type QuotaArrayOutput struct{ *pulumi.OutputState }

func (QuotaArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Quota)(nil)).Elem()
}

func (o QuotaArrayOutput) ToQuotaArrayOutput() QuotaArrayOutput {
	return o
}

func (o QuotaArrayOutput) ToQuotaArrayOutputWithContext(ctx context.Context) QuotaArrayOutput {
	return o
}

func (o QuotaArrayOutput) Index(i pulumi.IntInput) QuotaOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Quota {
		return vs[0].([]*Quota)[vs[1].(int)]
	}).(QuotaOutput)
}

type QuotaMapOutput struct{ *pulumi.OutputState }

func (QuotaMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Quota)(nil)).Elem()
}

func (o QuotaMapOutput) ToQuotaMapOutput() QuotaMapOutput {
	return o
}

func (o QuotaMapOutput) ToQuotaMapOutputWithContext(ctx context.Context) QuotaMapOutput {
	return o
}

func (o QuotaMapOutput) MapIndex(k pulumi.StringInput) QuotaOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Quota {
		return vs[0].(map[string]*Quota)[vs[1].(string)]
	}).(QuotaOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*QuotaInput)(nil)).Elem(), &Quota{})
	pulumi.RegisterInputType(reflect.TypeOf((*QuotaArrayInput)(nil)).Elem(), QuotaArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*QuotaMapInput)(nil)).Elem(), QuotaMap{})
	pulumi.RegisterOutputType(QuotaOutput{})
	pulumi.RegisterOutputType(QuotaArrayOutput{})
	pulumi.RegisterOutputType(QuotaMapOutput{})
}
