// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kafka
{
    /// <summary>
    /// The `kafka.Quota` resource manages Kafka quotas, which are used to limit resource usage and prevent any single client from monopolizing broker resources. Quotas can be applied to clients, users, or IP addresses to control bandwidth and request rates.
    /// 
    /// ## Example Usage
    /// 
    /// ### Client ID Quota
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Kafka = Pulumi.Kafka;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     // Limit a specific client's bandwidth
    ///     var mobileApp = new Kafka.Quota("mobile_app", new()
    ///     {
    ///         EntityName = "mobile-app-v1",
    ///         EntityType = "client-id",
    ///         Config = 
    ///         {
    ///             { "consumer_byte_rate", "5000000" },
    ///             { "producer_byte_rate", "2500000" },
    ///             { "request_percentage", "200" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### User Quota
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Kafka = Pulumi.Kafka;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     // Set quotas for a specific user
    ///     var serviceAccount = new Kafka.Quota("service_account", new()
    ///     {
    ///         EntityName = "payment-service",
    ///         EntityType = "user",
    ///         Config = 
    ///         {
    ///             { "consumer_byte_rate", "10000000" },
    ///             { "producer_byte_rate", "10000000" },
    ///             { "request_percentage", "400" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Default User Quota
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Kafka = Pulumi.Kafka;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     // Set default quotas for all users (when entity_name is omitted)
    ///     var defaultUser = new Kafka.Quota("default_user", new()
    ///     {
    ///         EntityType = "user",
    ///         Config = 
    ///         {
    ///             { "consumer_byte_rate", "2000000" },
    ///             { "producer_byte_rate", "1000000" },
    ///             { "request_percentage", "100" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### IP Address Quota
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Kafka = Pulumi.Kafka;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     // Rate limit connections from a specific IP
    ///     var externalIp = new Kafka.Quota("external_ip", new()
    ///     {
    ///         EntityName = "203.0.113.0",
    ///         EntityType = "ip",
    ///         Config = 
    ///         {
    ///             { "connection_creation_rate", "10" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Quota Configuration Options
    /// 
    /// ### Bandwidth Quotas
    /// - `ProducerByteRate` - The maximum bytes per second that can be produced by the entity
    /// - `ConsumerByteRate` - The maximum bytes per second that can be consumed by the entity
    /// 
    /// ### Request Rate Quotas
    /// - `RequestPercentage` - The percentage of CPU time on each broker that the entity can use for requests. Values &gt; 100% indicate multiple CPUs (e.g., 200% = 2 CPUs)
    /// 
    /// ### Connection Quotas (IP-based only)
    /// - `ConnectionCreationRate` - The maximum rate of new connections per second from the IP address
    /// 
    /// ## Quota Precedence
    /// 
    /// When multiple quotas apply to a request, Kafka uses the most specific quota:
    /// 
    /// 1. `/config/users/&lt;user&gt;/clients/&lt;client-id&gt;` (most specific)
    /// 2. `/config/users/&lt;user&gt;/clients/&lt;default&gt;`
    /// 3. `/config/users/&lt;user&gt;`
    /// 4. `/config/users/&lt;default&gt;/clients/&lt;client-id&gt;`
    /// 5. `/config/users/&lt;default&gt;/clients/&lt;default&gt;`
    /// 6. `/config/users/&lt;default&gt;` (least specific)
    /// 
    /// ## Best Practices
    /// 
    /// 1. **Start with Conservative Defaults**: Set reasonable default quotas for all users/clients and then create specific quotas for services that need higher limits.
    /// 
    /// 2. **Monitor Quota Usage**: Use Kafka metrics to monitor quota utilization and adjust as needed. Look for throttling metrics to identify when quotas are being hit.
    /// 
    /// 3. **Use Request Percentage Carefully**: The `RequestPercentage` quota affects CPU usage. Values over 100% mean the client can use more than one CPU core.
    /// 
    /// 4. **Plan for Growth**: Set quotas with some headroom to accommodate traffic growth, but not so high that a misbehaving client can impact the cluster.
    /// 
    /// 5. **Different Quotas for Different Environments**: Use stricter quotas in development/staging environments compared to production.
    /// 
    /// &gt; **Note:** Quotas are applied immediately but may take a few seconds to propagate across all brokers.
    /// 
    /// ## Import
    /// 
    /// Kafka quotas can be imported using the entity type and name:
    /// 
    /// For named entities
    /// 
    /// ```sh
    /// $ pulumi import kafka:index/quota:Quota example client-id:my-client
    /// ```
    /// 
    /// For default quotas (no entity name)
    /// 
    /// ```sh
    /// $ pulumi import kafka:index/quota:Quota default_user user:
    /// ```
    /// </summary>
    [KafkaResourceType("kafka:index/quota:Quota")]
    public partial class Quota : global::Pulumi.CustomResource
    {
        /// <summary>
        /// A map of string k/v properties.
        /// </summary>
        [Output("config")]
        public Output<ImmutableDictionary<string, string>?> Config { get; private set; } = null!;

        /// <summary>
        /// The name of the entity (if EntityName is not provided, it will create entity-default Kafka quota)
        /// </summary>
        [Output("entityName")]
        public Output<string?> EntityName { get; private set; } = null!;

        /// <summary>
        /// The type of the entity (client-id, user, ip)
        /// </summary>
        [Output("entityType")]
        public Output<string> EntityType { get; private set; } = null!;


        /// <summary>
        /// Create a Quota resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Quota(string name, QuotaArgs args, CustomResourceOptions? options = null)
            : base("kafka:index/quota:Quota", name, args ?? new QuotaArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Quota(string name, Input<string> id, QuotaState? state = null, CustomResourceOptions? options = null)
            : base("kafka:index/quota:Quota", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Quota resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Quota Get(string name, Input<string> id, QuotaState? state = null, CustomResourceOptions? options = null)
        {
            return new Quota(name, id, state, options);
        }
    }

    public sealed class QuotaArgs : global::Pulumi.ResourceArgs
    {
        [Input("config")]
        private InputMap<string>? _config;

        /// <summary>
        /// A map of string k/v properties.
        /// </summary>
        public InputMap<string> Config
        {
            get => _config ?? (_config = new InputMap<string>());
            set => _config = value;
        }

        /// <summary>
        /// The name of the entity (if EntityName is not provided, it will create entity-default Kafka quota)
        /// </summary>
        [Input("entityName")]
        public Input<string>? EntityName { get; set; }

        /// <summary>
        /// The type of the entity (client-id, user, ip)
        /// </summary>
        [Input("entityType", required: true)]
        public Input<string> EntityType { get; set; } = null!;

        public QuotaArgs()
        {
        }
        public static new QuotaArgs Empty => new QuotaArgs();
    }

    public sealed class QuotaState : global::Pulumi.ResourceArgs
    {
        [Input("config")]
        private InputMap<string>? _config;

        /// <summary>
        /// A map of string k/v properties.
        /// </summary>
        public InputMap<string> Config
        {
            get => _config ?? (_config = new InputMap<string>());
            set => _config = value;
        }

        /// <summary>
        /// The name of the entity (if EntityName is not provided, it will create entity-default Kafka quota)
        /// </summary>
        [Input("entityName")]
        public Input<string>? EntityName { get; set; }

        /// <summary>
        /// The type of the entity (client-id, user, ip)
        /// </summary>
        [Input("entityType")]
        public Input<string>? EntityType { get; set; }

        public QuotaState()
        {
        }
        public static new QuotaState Empty => new QuotaState();
    }
}
